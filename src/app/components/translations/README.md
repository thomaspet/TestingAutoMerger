# HOW TO NGRX

ngrx is an angular2 library to apply the Facebook's redux pattern

The goal of ngrx is to have state of the application centralized and decouple
components from the application logic

We start with an initial state of the app.

Each time a component needs to modify the state of the app it uses the 'Store' service to do it.
The store can dispatch an action.

An action is an object that contains the type of the action and a payload.
A payload is the information that the actions needs to construct a new state from the previous one.

```
//in the component
public onClick(item: Item) {
    this.store.dispatch({
        type: Actions.UPDATE_ITEM,
        payload: item
    });
}
```

As you can see the pattern uses the "throw and forget" concept. The component throws and action and forget about the rest.
It is the reducer who will generate a new state using the payload.

The store also acts as a BehaviorSubject so we can retrieve state from the store when we need it:

```
this.store.subscribe((state: AppState) => this.state = state)
```

That will be refreshed with each new state that is generated by the reducer

Usually we want to get some specific data from the store. We can use `select` or `map` for that:
```
this.store.select('property');
this.store.map(state => state.property);
```

## Reducers

A reducer is a pure function that gets an state and an action and generates a complete new state
```
(state, action) => state
```

Usually it follows the switch-case pattern.
Always should return a new instance of the state (inmutability)

```
(state = initialState, action) => {
    switch(action.type) {
        case Actions.ACTION_1: {
            return Object.assing({}, state, action.payload);
        },
        case Actions.ACTION_2: {
            state[payload.property] = payload.value;
            return Object.assing({}, state);
        }
        default:
            return state;
    }
}
```

# Effects

Sometimes we want that when an action occurs an other action happens immediately after. In other words we want that some
actions trigger other actions. A chain of actions. In that case we use effects.

Effects are defined as an Injectables so they are globally listening for actions in our module
When the action they listen for is triggered, the effects collect it and starts to work.

Usually effects are used to run the logic of the application that is not related directly with the state manipulation.
That means usually call other app services.

Since reducers are pure functions they have no access to the angular ecosystem, on the other hand, effects are services
so they have it, then we will use services to access to angular environment when we manipulate states.

```
    @Effect()
    public getItemEffect: Observable<Action> = this.actions$
        .ofType(item.ActionTypes.GET_ITEM)
        .switchMap((action: Action) => this.service.getItem(action.payload))
        .map((item: Item[]) => <Action>{type: item.ActionTypes.GET_ITEM_SUCCESS, payload: item})
        .catch(error => {
            this.toast.clear();
            console.error('ERROR GETTING ITEM: ', error);
            this.toast.addToast('Error getting item!', ToastType.bad, ToastTime.short, error.toString());
            const action: Action = {type: item.ActionTypes.GET_ITEM_FAIL, payload: error};
            return Observable.of(action);
        });
```

In the reducer
```
export itemReducer = (state = initialState, action) => {
    switch(action.type) {
        case Actions.GET_ITEM: {
            return Object.assing({}, state, { loading: true }); //we emit a new state saying we are loading
        },
        case Actions.GET_ITEM_SUCCESS: {
            return Object.assing({}, state, {
                loading: false, // data is get, we notify components we are not loading
                item: action.payload
            });
        },
        case Actions.GET_ITEM_FAIL: {
            return Object.assing({}, state, {
                loading: false, // data is get, we notify components we are not loading
                item: null,
                lastError: action.payload
            });
        },
        default: return state;
    }
}
```
